<!DOCTYPE html>
<html lang="id">
<head>
    <title>Main Tetris Online Gratis | Game Tetris HTML5 Seru</title>
    <meta name="description" content="Mainkan game Tetris klasik dengan gaya Game Boy langsung di browser Anda! Game Tetris HTML5 ini gratis, seru, dan bernuansa retro. Tanpa download, langsung main!">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

     <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7116287441723529"
     crossorigin="anonymous"></script>
<meta name="google-adsense-account" content="ca-pub-7116287441723529">
<meta name="google-site-verification" content="PpanBF5GPJQoPP-xX1s6wZvmIbym_qSxfoUbtX5EZVQ" />
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
          theme: {
            extend: {
              colors: {
                gbBody: '#c0c0c0',
                gbLightGray: '#e0e0e0',
                gbMediumGray: '#bababa',
                gbScreenGreen: '#77b300',
                gbDarkGreen: '#0f380f',
                gbBtnGray: '#a0a0a0',
                gbBtnHoverGray: '#c0c0c0',
                gbBtnActiveGray: '#909090',
                gbTetrominoCyan: '#8abe4a',
                gbTetrominoBlue: '#306850',
                gbTetrominoOrange: '#8abe4a',
                gbTetrominoYellow: '#8abe4a',
                gbTetrominoGreen: '#306850',
                gbTetrominoPurple: '#a2cfa5',
                gbTetrominoRed: '#306850',
              },
              fontFamily: {
                gbFont: ['monospace'],
              },
            }
          }
        }
    </script>
    <style type="text/tailwindcss">
        body {
            @apply bg-gbBody font-gbFont text-gbDarkGreen;
        }
        #game-container {
            @apply bg-gbLightGray rounded-none border-4 border-black shadow-inner max-w-90 box-border flex flex-row flex-wrap justify-center p-5 sm:p-5;
        }
        #game-info {
            @apply bg-gbMediumGray rounded-none border-2 border-black shadow-inner ml-5 sm:ml-5 p-3 sm:p-3 w-auto min-w-[120px] flex flex-col;
        }
        #score-level {
            @apply mb-2 sm:mb-2 text-sm sm:text-sm font-bold text-left text-shadow-none;
        }
        #next-tetromino-canvas {
            @apply bg-gbScreenGreen rounded-none border-2 border-black shadow-inner mt-2 sm:mt-2 w-[80px] h-[80px];
        }
        #tetris-canvas {
            @apply bg-gbScreenGreen rounded-none border-4 border-black shadow-inner max-w-full max-h-[360px] w-full h-auto;
        }
        #controls {
            @apply mt-4 sm:mt-4 text-center flex flex-wrap justify-center;
        }
        #controls button {
            @apply px-3 py-2 sm:px-3 sm:py-2 mx-1 sm:mx-1 text-xs sm:text-xs cursor-pointer bg-gbBtnGray text-black border-2 border-black rounded-none shadow-[2px_2px_3px_rgba(0,0,0,.5)] transition-colors duration-200 min-w-[70px];
        }
        #controls button:hover {
            @apply bg-gbBtnHoverGray;
        }
        #controls button:active {
            @apply bg-gbBtnActiveGray shadow-[1px_1px_2px_rgba(0,0,0,.5)] transform-translate-y-px;
        }
        h1 {
            @apply text-center text-gbDarkGreen mb-3 sm:mb-3 text-2xl sm:text-2xl text-shadow-none;
        }
        /* Mobile Styles */
        @media (max-width: 600px) {
            #game-container {
                @apply flex-col p-4 sm:p-4;
            }
            #game-info {
                @apply ml-0 mt-4 sm:mt-4 items-center min-w-auto w-full border-l-0 border-r-0 p-2 sm:p-2;
            }
            #score-level {
                @apply text-center;
            }
            #next-tetromino-canvas {
                @apply mt-2 sm:mt-2 w-[90px] h-[90px];
            }
            #tetris-canvas {
                @apply max-w-full max-h-[80vw];
            }
            #controls button {
                @apply px-4 py-2 sm:px-4 sm:py-2 text-sm sm:text-sm min-w-[70px];
            }
        }
    </style>
</head>
<body class="bg-gbBody font-gbFont text-gbDarkGreen p-5">
<div id="game-container" class="bg-gbLightGray rounded-none border-4 border-black shadow-inner max-w-90 box-border flex flex-row flex-wrap justify-center p-5">
    <div>
        <canvas id="tetris-canvas" width="240" height="400" class="bg-gbScreenGreen rounded-none border-4 border-black shadow-inner max-w-full max-h-[360px] w-full h-auto"></canvas>
        <div id="controls" class="mt-4 sm:mt-4 text-center flex flex-wrap justify-center">
            <button onclick="moveLeft()" class="px-3 py-2 sm:px-3 sm:py-2 mx-1 sm:mx-1 text-xs sm:text-xs cursor-pointer bg-gbBtnGray text-black border-2 border-black rounded-none shadow-[2px_2px_3px_rgba(0,0,0,.5)] transition-colors duration-200 min-w-[70px]">LEFT</button>
            <button onclick="rotate()" class="px-3 py-2 sm:px-3 sm:py-2 mx-1 sm:mx-1 text-xs sm:text-xs cursor-pointer bg-gbBtnGray text-black border-2 border-black rounded-none shadow-[2px_2px_3px_rgba(0,0,0,.5)] transition-colors duration-200 min-w-[70px]">ROTATE</button>
            <button onclick="moveRight()" class="px-3 py-2 sm:px-3 sm:py-2 mx-1 sm:mx-1 text-xs sm:text-xs cursor-pointer bg-gbBtnGray text-black border-2 border-black rounded-none shadow-[2px_2px_3px_rgba(0,0,0,.5)] transition-colors duration-200 min-w-[70px]">RIGHT</button>
            <button onclick="moveDown()" class="px-3 py-2 sm:px-3 sm:py-2 mx-1 sm:mx-1 text-xs sm:text-xs cursor-pointer bg-gbBtnGray text-black border-2 border-black rounded-none shadow-[2px_2px_3px_rgba(0,0,0,.5)] transition-colors duration-200 min-w-[70px]">DOWN</button>
            <button onclick="quickDrop()" class="px-3 py-2 sm:px-3 sm:py-2 mx-1 sm:mx-1 text-xs sm:text-xs cursor-pointer bg-gbBtnGray text-black border-2 border-black rounded-none shadow-[2px_2px_3px_rgba(0,0,0,.5)] transition-colors duration-200 min-w-[70px]">QUICK DROP</button>
        </div>
    </div>
    <div id="game-info" class="bg-gbMediumGray rounded-none border-2 border-black shadow-inner ml-5 sm:ml-5 p-3 sm:p-3 w-auto min-w-[120px] flex flex-col">
        <h1 class="text-center text-gbDarkGreen mb-3 sm:mb-3 text-2xl sm:text-2xl text-shadow-none">TETRIS</h1>
        <div id="score-level" class="mb-2 sm:mb-2 text-sm sm:text-sm font-bold text-left text-shadow-none">
            SCORE<br><span id="score">0</span><br><br>
            LEVEL<br><span id="level">1</span>
        </div>
        <div>NEXT</div>
        <canvas id="next-tetromino-canvas" width="120" height="120" class="bg-gbScreenGreen rounded-none border-2 border-black shadow-inner mt-2 sm:mt-2 w-[80px] h-[80px]"></canvas>
    </div>
</div>

<script>
  // ... (Kode JavaScript Anda tetap sama) ...
  const canvas = document.getElementById('tetris-canvas');
  const context = canvas.getContext('2d');
  const nextTetrominoCanvas = document.getElementById('next-tetromino-canvas');
  const nextTetrominoContext = nextTetrominoCanvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const levelElement = document.getElementById('level');

  const grid = 20;
  const canvasWidth = 240;
  const canvasHeight = 400;
  const gridCols = canvasWidth / grid;
  const gridRows = canvasHeight / grid;

  const nextCanvasWidth = 120;
  const nextCanvasHeight = 120;
  const nextGridCols = nextCanvasWidth / grid;
  const nextGridRows = nextCanvasHeight / grid;

  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameSpeed = 700; // milliseconds per frame
  let animationSpeed = 100; // milliseconds for animation frame

  const colors = [
    null,
    '#gbTetrominoCyan', /* cyan - Game Boy green */
    '#gbTetrominoBlue', /* blue - Dark Game Boy green */
    '#gbTetrominoOrange', /* orange - Game Boy green */
    '#gbTetrominoYellow', /* yellow - Game Boy green */
    '#gbTetrominoGreen', /* green - Dark Game Boy green */
    '#gbTetrominoPurple', /* purple - Light Game Boy green */
    '#gbTetrominoRed',  /* red - Dark Game Boy green */
    '#fff'      /* index 9 for animation white */
  ];

  const shapes = [
    [], // 0: empty
    [ [0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0] ], // 1: I
    [ [0,0,0],[1,1,0],[0,1,1],[0,0,0] ], // 2: Z
    [ [0,0,0],[0,1,1],[1,1,0],[0,0,0] ], // 3: S
    [ [0,0,0],[1,1,1],[0,1,0],[0,0,0] ], // 4: T
    [ [0,0,0],[1,1,0],[1,1,0],[0,0,0] ], // 5: O
    [ [0,0,0],[0,0,1],[1,1,1],[0,0,0] ], // 6: L
    [ [0,0,0],[1,0,0],[1,1,1],[0,0,0] ]  // 7: J
  ];

  let playfield = createPlayfield();
  let tetromino = getNewTetromino();
  let nextTetromino = getNewTetromino(); // Get the next tetromino
  let tetrominoPosition = {x: 0, y: 0};
  let isGameOver = false;
  let gameInterval;

  function createPlayfield() {
    const playfield = [];
    for (let row = 0; row < gridRows; row++) {
      playfield[row] = [];
      for (let col = 0; col < gridCols; col++) {
        playfield[row][col] = 0;
      }
    }
    return playfield;
  }

  function getNewTetromino() {
    const rand = Math.floor(Math.random() * 7) + 1;
    return {
      shape: shapes[rand],
      color: colors[rand]
    };
  }

  function resetTetromino() {
    tetromino = nextTetromino; // Current tetromino becomes the next one
    nextTetromino = getNewTetromino(); // Generate a new next tetromino
    tetrominoPosition.x = Math.floor(gridCols / 2 - tetromino.shape[0].length / 2);
    tetrominoPosition.y = 0;

    if (isColliding()) {
      gameOver();
    }
  }

  function isColliding() {
    const shape = tetromino.shape;
    const posY = tetrominoPosition.y;
    const posX = tetrominoPosition.x;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          let y = posY + row;
          let x = posX + col;

          if (y >= gridRows || x < 0 || x >= gridCols || playfield[y][x]) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function rotateTetromino() {
    const shape = tetromino.shape;
    const rotatedShape = [];

    for (let col = 0; col < shape[0].length; col++) {
      rotatedShape[col] = [];
      for (let row = shape.length - 1; row >= 0; row--) {
        rotatedShape[col].push(shape[row][col]);
      }
    }

    const originalShape = tetromino.shape;
    tetromino.shape = rotatedShape;
    if (isColliding()) {
      tetromino.shape = originalShape; // Revert rotation if collision
    }
  }

  function moveTetrominoHorizontally(moveX) {
    tetrominoPosition.x += moveX;
    if (isColliding()) {
      tetrominoPosition.x -= moveX; // Revert move if collision
    }
  }

  function moveTetrominoDown() {
    tetrominoPosition.y++;
    if (isColliding()) {
      tetrominoPosition.y--; // Revert move

      placeTetromino();
      clearFullRows();
      resetTetromino();
    }
  }

  function placeTetromino() {
    const shape = tetromino.shape;
    const posY = tetrominoPosition.y;
    const posX = tetrominoPosition.x;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          const colorName = tetromino.color.substring(1); // Remove '#'
          playfield[posY + row][posX + col] = colors.indexOf(`#${colorName}`); // Re-add '#' for color index
        }
      }
    }
  }


  async function animateClearRow(rowToClear) {
    return new Promise(resolve => {
      let animationFrames = 5; // Number of animation frames
      let frame = 0;
      const animationInterval = setInterval(() => {
        frame++;
        for (let col = 0; col < gridCols; col++) {
          if (frame % 2 === 0) {
            playfield[rowToClear][col] = 0; // Make cells disappear on even frames
          } else {
            playfield[rowToClear][col] = 9; // Use a special color index for flashing (e.g., 9 for white)
          }
        }
        drawPlayfield(); // Redraw playfield with animation
        if (frame >= animationFrames) {
          clearInterval(animationInterval);
          resolve();
        }
      }, animationSpeed); // Animation speed
    });
  }


  async function clearFullRows() {
    let rowsClearedThisTurn = 0;
    for (let row = gridRows - 1; row >= 0; row--) {
      if (playfield[row].every(cell => cell !== 0)) {
        rowsClearedThisTurn++;
        await animateClearRow(row); // Animate the row clearing
        playfield.splice(row, 1); // Remove full row
        playfield.unshift(Array(gridCols).fill(0)); // Add new empty row at the top
      }
    }

    if (rowsClearedThisTurn > 0) {
      linesCleared += rowsClearedThisTurn;
      score += 100 * level * rowsClearedThisTurn; // Score multiplier for clearing multiple rows
      scoreElement.innerText = score;

      if (linesCleared >= level * 5) { // Increase level every 5 lines cleared per level
        level++;
        levelElement.innerText = level;
        linesCleared = 0;
        gameSpeed = Math.max(100, gameSpeed - 50);
        clearInterval(gameInterval);
        startGame();
      }
    }
  }


  function gameOver() {
    isGameOver = true;
    clearInterval(gameInterval);
    alert(`Game Over! Skor: ${score}`);
    resetGame();
  }

  function resetGame() {
    playfield = createPlayfield();
    score = 0;
    level = 1;
    linesCleared = 0;
    gameSpeed = 700;
    scoreElement.innerText = score;
    levelElement.innerText = level;
    isGameOver = false;
    tetromino = getNewTetromino(); // Get initial tetromino
    nextTetromino = getNewTetromino(); // Get initial next tetromino
    startGame();
  }

  function drawPlayfield() {
    for (let row = 0; row < gridRows; row++) {
      for (let col = 0; col < gridCols; col++) {
        let cellValue = playfield[row][col];
        if (cellValue === 9) { // Animation color
          context.fillStyle = '#fff'; // White color for flashing animation
        } else {
          context.fillStyle = colors[cellValue] || '#gbScreenGreen'; // Default Game Boy screen color
        }
        context.fillRect(col * grid, row * grid, grid-1, grid-1);
      }
    }
  }

  function drawTetromino() {
    const shape = tetromino.shape;
    const color = tetromino.color;
    const posY = tetrominoPosition.y;
    const posX = tetrominoPosition.x;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          context.fillStyle = color;
          context.fillRect((posX + col) * grid, (posY + row) * grid, grid-1, grid-1);
        }
      }
    }
  }

  function drawNextTetromino() {
    nextTetrominoContext.clearRect(0, 0, nextCanvasWidth, nextCanvasHeight);
    const shape = nextTetromino.shape;
    const color = nextTetromino.color;
    const startX = (nextGridCols - shape[0].length) / 2; // Center the shape in preview canvas
    const startY = (nextGridRows - shape.length) / 2;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[0].length; col++) {
        if (shape[row][col]) {
          nextTetrominoContext.fillStyle = color;
          nextTetrominoContext.fillRect((startX + col) * grid, (startY + row) * grid, grid-1, grid-1);
        }
      }
    }
  }

  function draw() {
    context.clearRect(0, 0, canvasWidth, canvasHeight);
    drawPlayfield();
    drawTetromino();
    drawNextTetromino(); // Draw the next tetromino in preview canvas
  }

  function gameLoop() {
    if (!isGameOver) {
      moveTetrominoDown();
      draw();
    }
  }

  function startGame() {
    if (gameInterval) {
      clearInterval(gameInterval);
    }
    gameInterval = setInterval(gameLoop, gameSpeed);
    if (isGameOver) {
      isGameOver = false;
    }
    resetTetromino();
    draw();
  }

  function quickDrop() {
    while (!isColliding()) {
      tetrominoPosition.y++;
    }
    tetrominoPosition.y--;

    placeTetromino();
    clearFullRows();
    resetTetromino();
    draw();
  }


  // Control functions for buttons
  function moveLeft() {
    moveTetrominoHorizontally(-1);
    draw();
  }

  function moveRight() {
    moveTetrominoHorizontally(1);
    draw();
  }

  function moveDown() {
    moveTetrominoDown();
    draw();
  }

  function rotate() {
    rotateTetromino();
    draw();
  }


  // Keyboard controls
  document.addEventListener('keydown', function(e) {
    if (!isGameOver) {
      if (e.key === 'ArrowLeft') {
        moveLeft();
      } else if (e.key === 'ArrowRight') {
        moveRight();
      } else if (e.key === 'ArrowDown') {
        moveDown();
      } else if (e.key === 'ArrowUp') {
        rotate();
      } else if (e.key === ' ') {
        quickDrop();
      }
    }
  });

  resetGame();

</script>

</body>
</html>
