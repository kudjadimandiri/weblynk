<!DOCTYPE html>
<html lang="id"> <head>
<title>Main Tetris Online Gratis | Game Tetris HTML5 Seru</title> 
<meta name="description" content="Mainkan game Tetris klasik langsung di browser Anda! Game Tetris HTML5 ini gratis, seru, dan bisa dimainkan di desktop maupun perangkat mobile. Tanpa download, langsung main!"> 
<meta name="viewport" content="width=device-width, initial-scale=1.0"> <style>

<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-7116287441723529"
     crossorigin="anonymous"></script>
<meta name="google-adsense-account" content="ca-pub-7116287441723529">
<meta name="google-site-verification" content="PpanBF5GPJQoPP-xX1s6wZvmIbym_qSxfoUbtX5EZVQ" />

  body {
    background-color: #222;
    font-family: 'Arial', sans-serif;
    color: #eee;
    display: flex;
    justify-content: center;
    align-items: center;
    min-height: 100vh; /* Ubah height menjadi min-height untuk konten yang lebih panjang */
    margin: 0;
    padding: 20px; /* Tambahkan padding body untuk ruang di tepi layar mobile */
  }

  #game-container {
    display: flex;
    flex-direction: row;
    background-color: #333;
    padding: 25px; /* Kurangi padding container sedikit di mobile */
    border-radius: 15px;
    box-shadow: 0 0 20px rgba(0, 0, 0, 0.6);
    max-width: 90%; /* Lebar maksimum container untuk layar kecil */
    box-sizing: border-box; /* Pastikan padding tidak menambah lebar container */
    flex-wrap: wrap; /* Memungkinkan elemen di dalam container untuk wrap di layar kecil */
    justify-content: center; /* Pusatkan konten di dalam container */
  }

  #game-info {
    display: flex;
    flex-direction: column;
    margin-left: 20px; /* Kurangi margin kiri di mobile */
    padding: 15px; /* Kurangi padding info panel di mobile */
    border-radius: 8px;
    background-color: #444;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.5);
    width: auto; /* Lebar otomatis untuk info panel */
    min-width: 150px; /* Lebar minimum info panel */
  }

  #score-level {
    margin-bottom: 15px; /* Kurangi margin bawah di mobile */
    font-size: 18px; /* Ukuran font lebih kecil di mobile */
    font-weight: bold;
    text-shadow: 2px 2px 3px #111;
    text-align: center;
  }

  #next-tetromino-canvas {
    border: 2px solid #555;
    background-color: #111;
    border-radius: 8px;
    box-shadow: inset 0 0 5px rgba(0, 0, 0, 0.8);
    margin-top: 15px; /* Kurangi margin atas di mobile */
    width: 100px;  /* Ukuran canvas lebih kecil di mobile */
    height: 100px; /* Ukuran canvas lebih kecil di mobile */
  }

  #tetris-canvas {
    border: 4px solid #555;
    background-color: #111;
    border-radius: 8px;
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.8);
    width: 100%; /* Lebar kanvas 100% dari parent container */
    height: auto; /* Tinggi kanvas otomatis menyesuaikan aspek rasio */
    max-width: 240px; /* Lebar maksimum kanvas */
    max-height: 400px; /* Tinggi maksimum kanvas */
  }

  #controls {
    margin-top: 20px; /* Kurangi margin atas controls di mobile */
    text-align: center;
    display: flex; /* Gunakan flexbox untuk tombol-tombol */
    flex-wrap: wrap; /* Memungkinkan tombol wrap di layar kecil */
    justify-content: center; /* Pusatkan tombol-tombol */
  }

  #controls button {
    padding: 10px 20px; /* Ukuran padding tombol dikurangi sedikit di mobile */
    margin: 5px; /* Margin tombol dikurangi sedikit di mobile */
    font-size: 16px; /* Ukuran font tombol dikurangi sedikit di mobile */
    cursor: pointer;
    background-color: #444;
    color: #eee;
    border: none;
    border-radius: 8px;
    box-shadow: 3px 3px 5px rgba(0, 0, 0, 0.5);
    transition: background-color 0.3s ease;
    min-width: 80px; /* Lebar minimum tombol untuk sentuhan yang lebih mudah */
  }

  #controls button:hover {
    background-color: #666;
  }

  #controls button:active {
    background-color: #555;
    box-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
    transform: translateY(1px);
  }

  h1 { /* Gaya untuk tag H1 */
    text-align: center;
    color: #eee;
    margin-bottom: 20px;
    font-size: 2.5em;
    text-shadow: 3px 3px 5px #111;
  }

  /* Media query untuk layar yang lebih kecil dari 600px (mobile) */
  @media (max-width: 600px) {
    #game-container {
      flex-direction: column; /* Tumpuk elemen secara vertikal di mobile */
      padding: 20px; /* Padding container lebih kecil di mobile */
    }
    #game-info {
      margin-left: 0; /* Hilangkan margin kiri info panel di mobile */
      margin-top: 20px; /* Tambahkan margin atas info panel di mobile */
      align-items: center; /* Pusatkan item di info panel di mobile */
    }
    #tetris-canvas {
      max-width: 100%; /* Kanvas mengisi lebar container di mobile */
      max-height: 70vw; /* Batasi tinggi kanvas agar aspek rasio tetap terjaga dan tidak terlalu panjang di mobile */
    }
  }
</style>
</head>
<body>
  <div id="game-container">
    <div>
      <canvas id="tetris-canvas" width="240" height="400"></canvas>
      <div id="controls">
        <button onclick="moveLeft()">Kiri</button>
        <button onclick="rotate()">Putar</button>
        <button onclick="moveRight()">Kanan</button>
        <button onclick="moveDown()">Bawah</button>
        <button onclick="quickDrop()">Drop Cepat</button>
      </div>
    </div>
    <div id="game-info">
      <h1>Tetris Online</h1> <div id="score-level">
        Skor: <span id="score">0</span><br>
        Level: <span id="level">1</span>
      </div>
      <div>Blok Berikutnya:</div>
      <canvas id="next-tetromino-canvas" width="120" height="120"></canvas>
    </div>
  </div>

<script>
  // ... (Kode JavaScript Anda tetap sama) ...
  const canvas = document.getElementById('tetris-canvas');
  const context = canvas.getContext('2d');
  const nextTetrominoCanvas = document.getElementById('next-tetromino-canvas');
  const nextTetrominoContext = nextTetrominoCanvas.getContext('2d');
  const scoreElement = document.getElementById('score');
  const levelElement = document.getElementById('level');

  const grid = 20;
  const canvasWidth = 240;
  const canvasHeight = 400;
  const gridCols = canvasWidth / grid;
  const gridRows = canvasHeight / grid;

  const nextCanvasWidth = 120;
  const nextCanvasHeight = 120;
  const nextGridCols = nextCanvasWidth / grid;
  const nextGridRows = nextCanvasHeight / grid;

  let score = 0;
  let level = 1;
  let linesCleared = 0;
  let gameSpeed = 700; // milliseconds per frame
  let animationSpeed = 100; // milliseconds for animation frame

  const colors = [
    null,
    '#00ffff', /* cyan */
    '#0000ff', /* blue */
    '#ffa500', /* orange */
    '#ffff00', /* yellow */
    '#008000', /* green */
    '#800080', /* purple */
    '#ff0000',  /* red */
    '#fff'      /* index 9 for animation white */
  ];

  const shapes = [
    [], // 0: empty
    [ [0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0] ], // 1: I
    [ [0,0,0],[1,1,0],[0,1,1],[0,0,0] ], // 2: Z
    [ [0,0,0],[0,1,1],[1,1,0],[0,0,0] ], // 3: S
    [ [0,0,0],[1,1,1],[0,1,0],[0,0,0] ], // 4: T
    [ [0,0,0],[1,1,0],[1,1,0],[0,0,0] ], // 5: O
    [ [0,0,0],[0,0,1],[1,1,1],[0,0,0] ], // 6: L
    [ [0,0,0],[1,0,0],[1,1,1],[0,0,0] ]  // 7: J
  ];

  let playfield = createPlayfield();
  let tetromino = getNewTetromino();
  let nextTetromino = getNewTetromino(); // Get the next tetromino
  let tetrominoPosition = {x: 0, y: 0};
  let isGameOver = false;
  let gameInterval;

  function createPlayfield() {
    const playfield = [];
    for (let row = 0; row < gridRows; row++) {
      playfield[row] = [];
      for (let col = 0; col < gridCols; col++) {
        playfield[row][col] = 0;
      }
    }
    return playfield;
  }

  function getNewTetromino() {
    const rand = Math.floor(Math.random() * 7) + 1;
    return {
      shape: shapes[rand],
      color: colors[rand]
    };
  }

  function resetTetromino() {
    tetromino = nextTetromino; // Current tetromino becomes the next one
    nextTetromino = getNewTetromino(); // Generate a new next tetromino
    tetrominoPosition.x = Math.floor(gridCols / 2 - tetromino.shape[0].length / 2);
    tetrominoPosition.y = 0;

    if (isColliding()) {
      gameOver();
    }
  }

  function isColliding() {
    const shape = tetromino.shape;
    const posY = tetrominoPosition.y;
    const posX = tetrominoPosition.x;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          let y = posY + row;
          let x = posX + col;

          if (y >= gridRows || x < 0 || x >= gridCols || playfield[y][x]) {
            return true;
          }
        }
      }
    }
    return false;
  }

  function rotateTetromino() {
    const shape = tetromino.shape;
    const rotatedShape = [];

    for (let col = 0; col < shape[0].length; col++) {
      rotatedShape[col] = [];
      for (let row = shape.length - 1; row >= 0; row--) {
        rotatedShape[col].push(shape[row][col]);
      }
    }

    const originalShape = tetromino.shape;
    tetromino.shape = rotatedShape;
    if (isColliding()) {
      tetromino.shape = originalShape; // Revert rotation if collision
    }
  }

  function moveTetrominoHorizontally(moveX) {
    tetrominoPosition.x += moveX;
    if (isColliding()) {
      tetrominoPosition.x -= moveX; // Revert move if collision
    }
  }

  function moveTetrominoDown() {
    tetrominoPosition.y++;
    if (isColliding()) {
      tetrominoPosition.y--; // Revert move

      placeTetromino();
      clearFullRows();
      resetTetromino();
    }
  }

  function placeTetromino() {
    const shape = tetromino.shape;
    const posY = tetrominoPosition.y;
    const posX = tetrominoPosition.x;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          playfield[posY + row][posX + col] = colors.indexOf(tetromino.color);
        }
      }
    }
  }

  async function animateClearRow(rowToClear) {
    return new Promise(resolve => {
      let animationFrames = 5; // Number of animation frames
      let frame = 0;
      const animationInterval = setInterval(() => {
        frame++;
        for (let col = 0; col < gridCols; col++) {
          if (frame % 2 === 0) {
            playfield[rowToClear][col] = 0; // Make cells disappear on even frames
          } else {
            playfield[rowToClear][col] = 9; // Use a special color index for flashing (e.g., 9 for white)
          }
        }
        drawPlayfield(); // Redraw playfield with animation
        if (frame >= animationFrames) {
          clearInterval(animationInterval);
          resolve();
        }
      }, animationSpeed); // Animation speed
    });
  }


  async function clearFullRows() {
    let rowsClearedThisTurn = 0;
    for (let row = gridRows - 1; row >= 0; row--) {
      if (playfield[row].every(cell => cell !== 0)) {
        rowsClearedThisTurn++;
        await animateClearRow(row); // Animate the row clearing
        playfield.splice(row, 1); // Remove full row
        playfield.unshift(Array(gridCols).fill(0)); // Add new empty row at the top
      }
    }

    if (rowsClearedThisTurn > 0) {
      linesCleared += rowsClearedThisTurn;
      score += 100 * level * rowsClearedThisTurn; // Score multiplier for clearing multiple rows
      scoreElement.innerText = score;

      if (linesCleared >= level * 5) { // Increase level every 5 lines cleared per level
        level++;
        levelElement.innerText = level;
        linesCleared = 0;
        gameSpeed = Math.max(100, gameSpeed - 50);
        clearInterval(gameInterval);
        startGame();
      }
    }
  }


  function gameOver() {
    isGameOver = true;
    clearInterval(gameInterval);
    alert(`Game Over! Skor: ${score}`);
    resetGame();
  }

  function resetGame() {
    playfield = createPlayfield();
    score = 0;
    level = 1;
    linesCleared = 0;
    gameSpeed = 700;
    scoreElement.innerText = score;
    levelElement.innerText = level;
    isGameOver = false;
    tetromino = getNewTetromino(); // Get initial tetromino
    nextTetromino = getNewTetromino(); // Get initial next tetromino
    startGame();
  }

  function drawPlayfield() {
    for (let row = 0; row < gridRows; row++) {
      for (let col = 0; col < gridCols; col++) {
        let cellValue = playfield[row][col];
        if (cellValue === 9) { // Animation color
          context.fillStyle = '#fff'; // White color for flashing animation
        } else {
          context.fillStyle = colors[cellValue] || '#111';
        }
        context.fillRect(col * grid, row * grid, grid-1, grid-1);
      }
    }
  }

  function drawTetromino() {
    const shape = tetromino.shape;
    const color = tetromino.color;
    const posY = tetrominoPosition.y;
    const posX = tetrominoPosition.x;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col]) {
          context.fillStyle = color;
          context.fillRect((posX + col) * grid, (posY + row) * grid, grid-1, grid-1);
        }
      }
    }
  }

  function drawNextTetromino() {
    nextTetrominoContext.clearRect(0, 0, nextCanvasWidth, nextCanvasHeight);
    const shape = nextTetromino.shape;
    const color = nextTetromino.color;
    const startX = (nextGridCols - shape[0].length) / 2; // Center the shape in preview canvas
    const startY = (nextGridRows - shape.length) / 2;

    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[0].length; col++) {
        if (shape[row][col]) {
          nextTetrominoContext.fillStyle = color;
          nextTetrominoContext.fillRect((startX + col) * grid, (startY + row) * grid, grid-1, grid-1);
        }
      }
    }
  }

  function draw() {
    context.clearRect(0, 0, canvasWidth, canvasHeight);
    drawPlayfield();
    drawTetromino();
    drawNextTetromino(); // Draw the next tetromino in preview canvas
  }

  function gameLoop() {
    if (!isGameOver) {
      moveTetrominoDown();
      draw();
    }
  }

  function startGame() {
    if (gameInterval) {
      clearInterval(gameInterval);
    }
    gameInterval = setInterval(gameLoop, gameSpeed);
    if (isGameOver) {
      isGameOver = false;
    }
    resetTetromino();
    draw();
  }

  function quickDrop() {
    while (!isColliding()) {
      tetrominoPosition.y++;
    }
    tetrominoPosition.y--;

    placeTetromino();
    clearFullRows();
    resetTetromino();
    draw();
  }


  // Control functions for buttons
  function moveLeft() {
    moveTetrominoHorizontally(-1);
    draw();
  }

  function moveRight() {
    moveTetrominoHorizontally(1);
    draw();
  }

  function moveDown() {
    moveTetrominoDown();
    draw();
  }

  function rotate() {
    rotateTetromino();
    draw();
    }


  // Keyboard controls
  document.addEventListener('keydown', function(e) {
    if (!isGameOver) {
      if (e.key === 'ArrowLeft') {
        moveLeft();
      } else if (e.key === 'ArrowRight') {
        moveRight();
      } else if (e.key === 'ArrowDown') {
        moveDown();
      } else if (e.key === 'ArrowUp') {
        rotate();
      } else if (e.key === ' ') {
        quickDrop();
      }
    }
  });

  resetGame();

</script>

</body>
</html>
